# Advent of Code 2025
These are my scripts for the puzzles at https://adventofcode.com/2025 . Same as the previous years, I will be uploading all days that I solve with a short commentary on thought process/description. All the puzzles (so far) have been solved without looking up any hint related to the event. Note that my naming process for the input texts is input + the date. So for the first day it was input1.txt, the second day input2.txt... etc.

## Day 1
Again, the first days are generally easy, so I didn't expect much. Part 1 was about keeping track of a position, using a little modular arithmetic. Part 2 just needed to calculate the number of turns as well after each command, with some caution for edge cases to not double count or miscount.

## Day 2
Day 2 was fairly easy too. In fact I misread the prompt and did wrote the code for part 2 before I finished part 1. Part 1 was basically about splitting the words in half and seeing if those halves match. In part 2, I reinvented the wheel and wrote a function to find the divisors of numbers instead of grabbing a ready made one. Then checked the "sub-strings" of length corresponding to divisors of the length of the full string to see if the full string is made out of copies of those sub-strings. Small note for edge cases where the full string was of length "1". 

## Day 3
Day 3 didn't have anything special either. For part 1, you needed to find the largest concatenation of 2 digits inside a multi digit string. You just had to realize that you need to search the entire string minus the last character to find the first digit, and then from the first digit to the end to find the second digit. For part 2, you had to find the largest concatenation of 12 digits this time. The logic was the same though, you search the entire string minus the last 11 characters for the first digit, then from the first digit up until 10 characters before the end for the second digit, and so on...

## Day 4
Day 4 was quite easy as well. In part 1, we had a grid of "." and "@" characters and we had to check the surrounding block of all "@" characters to see how many of them were also the character "@" and count it if it's less than 4. For part 2, we just had to remove all the characters that met the previous condition and repeat until there are no more characters to remove.

## Day 5
Day 5 was the first day to have an interesting part. Part 1 was easy as well, we just had to figure out how many numbers within a set are inside a set of ranges. Part 2 was more tricky. We to find how many numbers in total were in that set of ranges. For this you have to take care of edge cases like a range within another range, a range half within another, a range encompassing two or more ranges... The way I did it was I sorted the ranges based on their start value and then progressively added more ranges to my set with a set of conditions, if the new range was entirely within the previous range then I ignored it, if the start of the new range was less then the end of the previous range (and the end of the new was greater than the end of the previous) then I adjust the end of the previous range to match the end of the new range... otherwise, I just appended the new range. This takes care of all edge cases.

## Day 6
Day 6 was also interesting and... annoying maybe in a funny way. Part 1 was about taking an array of numbers and transposing it essentially. For part 2, we also had to take into account the vertical alignment of those numbers as we were supposed to read them top to bottom. This means that parsing the lines is a bit more tricky now because the number of spaces matter and then the whole reading the array top to bottom. What I did for parsing was find the columns that were all spaces which were the true separators and then kept the other spaces. Then I used appropriate conditions to read the numbers top to bottom. Overall pretty interesting day, took a bit to take care of all the issues. 

## Day 7
Day 7 was easy but interesting. Part 1 was following the path of a beam and tracking how it's being split. It is made easier by the fact that beams at the same spot merge together so the number of different beams doesn't exponentially increase. This is why I used sets for this part because we do not care about duplicate beams. Part 2 (if it wasn't obvious) starts caring about duplicate beams. Theoretically the solution could be done with tracking all the individual beams as list entires but their number as mentioned previously increases exponentially and it would take too long. Instead, I useda dictionaryto track the beams, not caring about duplicates but counting the multiplicity of each beam. If two beams are at the same spot, I track them as one beam with multiplicity the sum of the multiplicities of the previous two beams. As a simple example, at the very start if two beams merge then I count them as one beam with multiplicity 2. Then at the end I just add up the multiplicity of all beams.