# Advent of Code 2025
These are my scripts for the puzzles at https://adventofcode.com/2025 . Same as the previous years, I will be uploading all days that I solve with a short commentary on thought process/description. All the puzzles (so far) have been solved without looking up any hint related to the event. Note that my naming process for the input texts is input + the date. So for the first day it was input1.txt, the second day input2.txt... etc.

## Day 1
Again, the first days are generally easy, so I didn't expect much. Part 1 was about keeping track of a position, using a little modular arithmetic. Part 2 just needed to calculate the number of turns as well after each command, with some caution for edge cases to not double count or miscount.

## Day 2
Day 2 was fairly easy too. In fact I misread the prompt and did wrote the code for part 2 before I finished part 1. Part 1 was basically about splitting the words in half and seeing if those halves match. In part 2, I reinvented the wheel and wrote a function to find the divisors of numbers instead of grabbing a ready made one. Then checked the "sub-strings" of length corresponding to divisors of the length of the full string to see if the full string is made out of copies of those sub-strings. Small note for edge cases where the full string was of length "1".

## Day 3
Day 3 didn't have anything special either. For part 1, you needed to find the largest concatenation of 2 digits inside a multi digit string. You just had to realize that you need to search the entire string minus the last character to find the first digit, and then from the first digit to the end to find the second digit. For part 2, you had to find the largest concatenation of 12 digits this time. The logic was the same though, you search the entire string minus the last 11 characters for the first digit, then from the first digit up until 10 characters before the end for the second digit, and so on...

## Day 4
Day 4 was quite easy as well. In part 1, we had a grid of "." and "@" characters and we had to check the surrounding block of all "@" characters to see how many of them were also the character "@" and count it if it's less than 4. For part 2, we just had to remove all the characters that met the previous condition and repeat until there are no more characters to remove.

## Day 5
Day 5 was the first day to have an interesting part. Part 1 was easy as well, we just had to figure out how many numbers within a set are inside a set of ranges. Part 2 was more tricky. We to find how many numbers in total were in that set of ranges. For this you have to take care of edge cases like a range within another range, a range half within another, a range encompassing two or more ranges... The way I did it was I sorted the ranges based on their start value and then progressively added more ranges to my set with a set of conditions, if the new range was entirely within the previous range then I ignored it, if the start of the new range was less then the end of the previous range (and the end of the new was greater than the end of the previous) then I adjust the end of the previous range to match the end of the new range... otherwise, I just appended the new range. This takes care of all edge cases.

## Day 6
Day 6 was also interesting and... annoying maybe in a funny way. Part 1 was about taking an array of numbers and transposing it essentially. For part 2, we also had to take into account the vertical alignment of those numbers as we were supposed to read them top to bottom. This means that parsing the lines is a bit more tricky now because the number of spaces matter and then the whole reading the array top to bottom. What I did for parsing was find the columns that were all spaces which were the true separators and then kept the other spaces. Then I used appropriate conditions to read the numbers top to bottom. Overall pretty interesting day, took a bit to take care of all the issues.

## Day 7
Day 7 was easy but interesting. Part 1 was following the path of a beam and tracking how it's being split. It is made easier by the fact that beams at the same spot merge together so the number of different beams doesn't exponentially increase. This is why I used sets for this part because we do not care about duplicate beams. Part 2 (if it wasn't obvious) starts caring about duplicate beams. Theoretically the solution could be done with tracking all the individual beams as list entires but their number as mentioned previously increases exponentially and it would take too long. Instead, I useda dictionaryto track the beams, not caring about duplicates but counting the multiplicity of each beam. If two beams are at the same spot, I track them as one beam with multiplicity the sum of the multiplicities of the previous two beams. As a simple example, at the very start if two beams merge then I count them as one beam with multiplicity 2. Then at the end I just add up the multiplicity of all beams.

## Day 8
Day 8 was a bit tricky. For part 1 we had to perform the 1000 shortest connections in a set of coordinates. It wasn't that difficult to implement but a bit annoying to understand exactly what the exercise wanted. Part 2 initially seemed to be a very computationally heavy exercise that we would need to optimize but once I took out all unnecessary steps from part 1, then the computation of part 2 was very quick. I found that weird since usually these exercises would need us to work in a smarter way to get the result but this was just taking part 1's code and adjusting it to part 2.

## Day 9
Day 9 is where it started to get difficult. Part 1 was easy, we had to find the biggest rectangle that could be formed with a pair of points (as opposite ends of the rectangle) with the points taken from a list. For part 2, it turns out these points are the many corners of a (non-convex) polygon. To solve it, we had to find the biggest rectangle with the same conditions as part 1 but in addition to that, the rectangle had to be entirely within the polygon. It took a while to find an efficient way to solve it. The idea is inspired a bit by my solution to Advent of Code 2023 day 10. We kind of needed a way to tell when a point is within the polygon or not. To find that, we get the list of points and create the boundary line of the polygon while also keeping track of the direction of movement. Then it is easy to see by looking at the points with which orientation the boundary moves around the polygon, which would be either clockwise or counter clockwise. If it's clockwise it means that when moving along the boundary, the polygon will be on our "right" side, in practice this means that if the boundary is going left then the inside of the polygon will be up, if the boundary is moving up the inside will be on the right... etc. Having this tool, we can check if an individual point is inside the polygon fairly quickly, however, we cannot just go and check for every pair of points if all the other points inside the rectangle they create are inside the polygon. What I did instead is that for every individual corner point, I found how far up, down, left and right you can go while still remaining in the polygon, then I combined this information in what I called the "box". Then for every pair of points, I first checked if both were in each other's "box". Now, knowing that point "A" is within the box of point "B" does not give that much information on its own since the turns of the polygon could make it so that the rectangle formed with corners "A" and "B" ends up being partly outside the polygon. However, if both "A" and "B" are within each other's polygon, I believe that unless the shape has non-trivial homology (aka a hole), it is not possible for the rectangle with corners "A" and "B" to have any points outside the rectangle. So that's what I did, I took every pair, checked that they are within each other's boxes and then from those that were, I found the biggest rectangle and the answer turned out to be correct. Overall pretty great day, my favorite so far since it involved a bit of topology.      

## Day 10
Day 10 was the hardest so far. It was very reminiscent of 2023's day 12. The main idea is that we had to press buttons to put the system in a certain configuration and the point is to find the least amount of button presses. For part 1, all you needed to figure out was that you can only press each button once at most (since each state is either on or off) so a simple brute force solution among all button configurations works. Part 2 was much harder, there is no more "mod 2" factor in the problem. It essentially turns into a linear algebra problem where we have to find the amount of button presses for each button to put the system in a certain configuration. Now the systems came in various different forms... some were underdetermined some overdetermined etc. For the overdetermined ones, it is not too difficult to find a solution and that solution is unique. For the underdetermined ones I had to do a lot of trial and error to find answers. I ended up iterating over the extra degrees of freedom to find the solution with the lowest number of button presses. There were also a couple more optimizations. I used an algorithm I made during my Master's about separating a Matrix's nullspace and another optimization for when some buttons are redundant as they affect a unique part of the configuration so we know exactly how many times they should be pressed. Overall, pretty difficult exercise, I broke my soft rule for the first time this year about not using external libraries as I really wanted sympy and also itertools is very useful. Also for the first time this year I didn't solve the problem on the same day so yeah... things were tough.

## Day 11
Day 11 was not that hard. The puzzle is about a directed graph and for part 1 we need to find all different paths connecting two elements/nodes. I just implemented a recursive function and also a memory to speed up things (an idea from previous years). If the function computes the paths from "A" to "B" then it inputs that in memory so if we need to compute them again then we take that saved value. After that the problem was pretty simple. Part 2 was also not that difficult. It required all paths going from "A" to "D" while passing through "B" and "C". Because of the nature of the problem we can imagine there are no loops so we only need to look at the number of paths going from "A" to "B" then from "B" to "C" then from "C" to "D" and multiply those numbers together to get the answer. Overall, pretty easy day. 

## Day 12
Day 12 was weird. First of all I did not expect it to be the last day, I realized later that there would be only 12 days this year. I figured that this meant that day 12 would only have 1 part (and it turned out I was correct). The problem itself a priori seemed very hard. We had a bunch of irregular shapes and we had to check if they fit within an area (and check that multiple times over with different numbers of each shape and area sizes). My first thought was to exclude the cases where the total size of the shapes exceeded the total size of the area as there would be no way they'd fit. My second thought was to automatically count the case as "fitting" if the total area is bigger than the the total size of the shapes if they were convex (so every shape replaced with a square that covers it). Technically, even for that case, we could still get edge cases where the area fits but the convex squares don't fit in the area themselves (for example  152 3x3 squares would not fit in a 36x38 area even though their areas are equal), but even in those cases, we could easily use the actual shapes to save a few lines of space so I did not consider these edge cases. Then the remaining cases should be the ones we should actually compute and turns out those are... 0. Turns out all the cases we needed to compute either obviously don't fit inside the area or easily fit within the area... there are no cases where they fit but we need to pack them in a smart way. At first I thought it was an error but I inputted the number of cases that fit the second scenario and it turns out it was correct. Overall, very weird day, did not feel satisfying but rather cheesy as we didn't solve the problem it asked for but rather realized that there was no problem to solve. Of course, solving the actual problem might be very highly non-trivial... I can't imagine irregular shape packing is an easy problem and (I might be wrong here) could be unsolvable in the general case save for brute force. 

# Final thoughts
As always, I finish advent of code with some closing thoughts. Today was a difficult year for me as I was quite busy during the start of December. That being said, most days were pretty easy but then it got quite hard with day 9 and after day 10 got much much harder and took a lot of time for me to solve. So much so that I left days 11 and 12 for the weekend, but it turned out those were very easy days themselves. I found day 12 a bit disappointing though. I've used cheesy solutions before, especially on some problems with combinatorics or linear algebra or that one graph theory on day 25, 2 years ago, but I always solved the actual problem and the solutions should work (maybe slowly but they work) for almost all if not all possible realistic inputs. This felt like not actually solving the problem. I was also slightly disappointed by the whole event being 12 days in total, and I was looking forward to doing the more difficult days (which usually were around day 20) during my days off work, but I understand that making those puzzles is a lot of effort so I do not blame the creators for doing only 12 days this year. Overall though, pretty fun experience. I will probably be doing it next year too. 